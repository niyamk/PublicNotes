# üìùPublic Note Boardüìù

---

### üìò Overview

**Public Note Board** is a simple and dynamic "digital bulletin board" built using the ASP.NET Core MVC framework. It provides a clean, dark-mode interface where all users share the same board. Any visitor can publicly post a note, edit existing notes, or delete notes, with all changes visible to everyone.

---

### üíª Tech Stack

This project is built with a modern .NET and web stack:

* **üß† Backend:** ASP.NET Core MVC (.NET 9 / .NET 6+)
* **üß∞ Language:** C#
* **üóÉÔ∏è Database:** Entity Framework Core with SQLite
* **üé® Frontend:** HTML5, CSS3, Bootstrap 5
* **‚öôÔ∏è Tooling:** `dotnet-ef` for database migrations

---

### üöÄ Steps To Run

#### ‚úÖ Prerequisites

* [.NET SDK](https://dotnet.microsoft.com/en-us/download) (Version 6.0 or newer)
* [EF Core Global Tool](https://learn.microsoft.com/en-us/ef/core/cli/dotnet#installing-the-tools)
    ```sh
    dotnet tool install --global dotnet-ef
    ```
* A code editor like Visual Studio or VS Code

#### ‚ñ∂Ô∏è Running the Project

1.  **Clone the Repository**
    ```sh
    git clone https://github.com/niyamk/PublicNotes.git
    cd PublicNotes
    ```

2.  **Restore Dependencies**
    ```sh
    dotnet restore
    ```

3.  **Create the Database**
    This is a crucial step to set up your local `app.db` file.
    ```sh
    dotnet ef database update
    ```

4.  **Run the Project**
    ```sh
    dotnet run
    ```

5.  **Open Your Browser**
    Navigate to the local URL shown in your terminal (usually `http://localhost:5xxx` or `https://localhost:7xxx`).

# Project Documentation: Public Note Board

This document provides an in-depth explanation of the project's architecture, file structure, and feature implementation.

---

## 1. Project Architecture

This application is built using the **ASP.NET Core MVC** (Model-View-Controller) design pattern.

* **Model (`Models/Note.cs`):** Represents the data. It's a simple C# class that defines what a "Note" is (an `Id`, `Title`, `Content`, and `CreatedAt` date).
* **View (`Views/Notes/`):** The user interface (UI). These are the `.cshtml` (Razor) files that combine HTML with C# code to display the data.
* **Controller (`Controllers/NotesController.cs`):** The "brain" of the application. It handles user requests from the View, gets data from the Model (via the database), and decides which View to show.

### Database: Entity Framework Core

We use **Entity Framework (EF) Core** as our ORM (Object-Relational Mapper).

* **`Data/ApplicationDbContext.cs`:** This class is the "bridge" between our C# `Note` model and the database. It tells EF Core that we want a database table called `Notes`.
* **`app.db`:** This is the physical **SQLite** database file. It's a lightweight, serverless database contained in a single file.
* **`Migrations` folder:** These files are auto-generated by EF Core. They are instructions that tell the database how to update its schema (e.g., "create a new table" or "remove a column").

---

## 2. Feature Implementation

### Displaying Notes (Main Page)

* **File:** `Views/Notes/Index.cshtml`
* **Logic:** The page uses a `@foreach (var note in Model)` loop to iterate over the list of notes provided by the `NotesController`.
* **Layout:** The "masonry" (waterfall) effect is achieved *without* JavaScript. We use a simple CSS `div` wrapper:
    ```css
    <div style="column-width: 320px; column-gap: 1rem;">
      </div>
    ```
    The `break-inside: avoid;` style on each card prevents a single card from splitting across two columns.

### Create, Edit, and Delete (CRUD)

All logic is handled in `Controllers/NotesController.cs`.

1.  **Create:**
    * The form in `Index.cshtml` `POST`s data to the `Create(...)` action.
    * The action adds the new `Note` object to the `_context` and calls `_context.SaveChangesAsync()`.
    * It then redirects the user back to the `Index` page.

2.  **Edit:** (This is a 2-step process)
    * **Step 1 (GET):** The "Edit" button links to the `Edit(int id)` action. This action finds the note by its `id`, and then passes that `Note` object to the `Edit.cshtml` view.
    * **Step 2 (POST):** The form in `Edit.cshtml` `POST`s the *updated* note data to the second `Edit(int id, Note note)` action. This action tells the context to `_context.Update(note)` and saves the changes.

3.  **Delete:**
    * The "Delete" button is a small `<form>` that `POST`s to the `Delete(int id)` action.
    * The action finds the note by `id`, calls `_context.Notes.Remove(note)`, and saves the changes.

### Real-Time Updates with SignalR

This feature prevents users from needing to refresh the page to see new notes.

* **Server-Side:**
    1.  **`Program.cs`:** We register the SignalR service (`builder.Services.AddSignalR()`) and map a connection endpoint (`app.MapHub<NoteHub>("/noteHub")`).
    2.  **`Hubs/NoteHub.cs`:** A simple, empty class that acts as the connection point.
    3.  **`NotesController.cs`:**
        * We inject the `IHubContext<NoteHub>` into the controller's constructor.
        * In the `Create` action, after the note is successfully saved, we call this line:
            ```csharp
            await _hubContext.Clients.All.SendAsync("NewNotePosted");
            ```
        * This "broadcasts" the message "NewNotePosted" to *every client* currently connected to the hub.

* **Client-Side:**
    1.  **`Views/Notes/Index.cshtml`:** A `@section Scripts` block is added to the bottom of the file.
    2.  This script includes the SignalR client library.
    3.  It builds a connection to our `/noteHub` endpoint.
    4.  It *listens* for the message from the server:
        ```javascript
        connection.on("NewNotePosted", function () {
            // When we get the message, reload the page.
            location.reload();
        });
        ```
    5.  `connection.start()` activates the listener.

# üì∏ Screenshots üì∏
<img width="1907" height="1079" alt="image" src="https://github.com/user-attachments/assets/6bceaa2e-0a4e-4ea4-a3a0-f6a302b3ba3b" />



